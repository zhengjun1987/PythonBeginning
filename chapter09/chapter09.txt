第九章 魔法方法、特性和迭代器
Python中的很多名称很特别，开头和末尾都有两个下划线 —— 这种拼写具有特殊意义；很大一部分是魔法方法，在特定的情形下会被Python调用，无需直接调用

第一节 构造函数
	构造函数即对象创建之后自动调用的初始化方法，命名为__init__
	为构造函数添加参数 (见 constructor.py)

	一、重写普通方法和特殊的构造函数
		重写超类方法是继承的一个重要方面，对构造函数尤其重要。
	二、调用未关联的超类构造函数
		super().__init__()

第二节 元素访问 —— 一组很有用的方法，让你能够创建行为类似于序列或映射的对象
	一、基本的序列和映射协议：序列和映射基本上是元素的集合（不可变对象实现2个方法，可变对象实现4个方法）
		__len__(self)方法：返回集合所包含元素个数、键值对数；若返回0，则在布尔上下文中被视为False
		__getitem__(self,key)方法：返回与指定键相关的值
		__setitem__(self,key,value)方法：以与键相关联的方式存储值；仅当对象可变时才需要实现此方法
		__delitem__(self,key)方法：此方法在对对象的组成部分使用__del__语句时被调用，应删除与key对应的值；仅当对象可变时才需要实现此方法
	二、从list、dict和str派生
		如果只是想定制某种操作的行为，就没有必要去重新实现其他所有方法：继承
		标准库中，模块collections提供了抽象和具体的基类，也可以继承内置类型

第三节 特性
一、函数property
	Python能够替你隐藏存取方法，让所有的属性看起来都一样。通过存取方法定义的属性通常称为特性（property）。
	通过调用函数property并将存取方法作为参数（获取方法在前，设置方法在后）创建了一个特性，然后将名称size关联到这个特性。这样，你就能以同样的方式对待width、height和size，而无需关心它们是如何实现的。(见 rectangle.py)

二、静态方法和类方法
	静态方法和类方法是这样创建的：将它们分别包装在staticmethod和classmethod类的对象中。
	静态方法的定义中没有参数self，可直接通过类来调用。
	类方法的定义中包含类似于self的参数，通常被命名为cls。对于类方法，也可通过对象直接调用，但参数cls将自动关联到类。

三、__getattr__、__setattr__等方法
	拦截对对象属性的所有访问企图，四个方法：
		__getattribute__(self, name)：属性被访问时自动调用
		__getattr__(self, name)：在属性被访问而对象没有这样的属性时调用
		__setattr__(self, name)：试图给属性赋值时调用；
				编写该方法时需避开无限循环陷阱，在该方法中若需修改对象属性值可以直接访问self.__dict__
		__delattr__(self, name)：试图删除属性时调用
		self.__dict__是一个字典，包含了当前实例的所有属性

第四节 迭代器
一、迭代器协议
	迭代：像循环一样重复多次。凡是实现了__iter__方法的对象都可以迭代
	__iter__方法返回一个具备__next__方法的迭代器对象；__next__方法返回下一个元素值，如果没有下一个元素值则引发StopIterationException

第五节 生成器simple generator —— 一种使用普通函数语法定义的迭代器
一、创建生成器
	包含yield语句的函数都被称为生成器，生成器和普通函数的行为截然不同：
		1.普通函数使用return返回一个值
		2.生成器使用yield生成多个值，每次一个；每次使用yield一次之后函数都将冻结，即在此停止执行；被重新唤醒后，函数将从之前停止的地方开始继续执行
二、递归式生成器 —— 处理任意层嵌套列表
三、通用生成器
	生成器是包含关键字yield的函数，但被调用时不会执行函数体内的代码；而是返回一个迭代器，每次请求值时，都会执行生成器代码，直到遇到yield或return
	生成器由两个部分组成：
		1.生成器的函数：由def定义的，包含yield语句。生成器的迭代器是这个函数返回的结果
		2.生成器的迭代器：可以视为一般迭代器使用
四、生成器的方法
	生成器开始运行后，可以使用生成器和外部之间的通信渠道向它提供值
	通信渠道包括两个端点：
		1.外部世界：可用方法send访问生成器，类似于next，但要接收一个参数
		2.生成器：在挂起的生成器内部，yield可能用作表达式而非语句；当生成器重新运行时yield返回一个值，通过send从外部世界发送的值
			仅当生成器被挂起之后使用send才有意义
	第一个next调用之前只能通过生成器函数向生成器传输初始化信息
	第一个next调用之后可以使用gen.send(obj)向生成器传输信息，获取点是yield语句的表达式值

第六节 八皇后问题
逐步得到结果的复杂递归算法，非常适合使用生成器来计算 —— 所有的递归调用只需生成其负责部分的结果 —— 遍历图结构和树结构7

