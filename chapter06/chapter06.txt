第六章 抽象

第一节 懒惰即美德 —— 让代码更抽象、便于复用

第二节 抽象和结构
	抽象可以节省人力
	抽象可以让人更容易理解程序的关键所在：计算机本身更喜欢明确的指令，而人不是的

第三节 自定义函数 —— 函数是结构化编程的核心import math
		x = 1
		y = math.sqrt
		callable(x)
		False
		callable(y)
		True
	一、创建自定义函数：
		def fibs(num):
		    ressult = [0,1]
		    for i in range(num - 2):
		        ressult.append(ressult[-2]+ressult[-1])
		    return ressult
		fibs(10)
		[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
		fibs(15)
		[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]
	二、给函数编写文档
		1.可以添加注释
		2.添加独行的字符串（def语句的后面、模块和类的开头）；可以通过__doc__属性访问；也可以通过内置的help函数访问
	三、其实并非函数的函数
		数学意义上的函数是指根据参数计算并返回的结果
		但在Python中某些函数什么都不返回，使用return语句只是为了结束函数
	四、参数魔法
		1.值从哪里来 —— 函数的职责是确保在参数正确时完成计算任务，在参数错误时以显而易见的方式失败（断言或异常）
		2.参数能够修改吗 —— 形式参数与实际参数 参数作用域
			字符串、数、元组是不可变的immutable，意味着无法修改它们，只能将其指向新的值
			切片操作无论是否是切片到什么范围都是在原列表的基础上新建新的列表	
		3.关键字参数和默认值 —— 调用函数时指定参数名，可以无视参数的顺序位置 
			位置参数：不提供默认值，排在参数列表的前面
			关键字参数：可以提供默认值，无所谓位置
		4.可变参数列表 —— 参数收集
			函数设计时在参数名前面加‘*’可以作为一个元组收集多个参数
			函数设计时在参数名前面加‘**’可以作为一个元组收集包含有名参数在内的多个参数
	五、分配参数
		函数调用时在参数名前面加“*”可以将一个元组拆分为函数的各个参数 —— 条件时这部分参数位于参数列表的末尾
		通过“**”还可以将字典的值也分配给参数
		如果定义和调用时都使用了“*”或“**”，将只传递元组或字典 —— 此时定义和调用的*均可省略
	六、练习使用参数（综合示例） —— 见 storyteller.py

第四节 作用域
	作用域的真面目 —— 看不见的字典，方法vars返回这个字典
	局部变量、全局变量：参数是一种局部变量，局部变量和全局变量同名不会有任何问题
		globals()用于返回全局变量字典，locals()用于返回局部变量字典
	闭包 —— 返回函数的函数

第五节 递归
	常见的递归函数包括两个部分：
		① 基线条件 —— 针对最小最基本的问题，满足这种条件时会返回一个值
		② 递归条件 —— 包含一个或多个调用，旨在解决问题的某一部分
	问题最终会被分解成基线问题可以解决的小问题

	函数式编程：
		list(map(int,"12 3 4 5 6 7 8 9".split(' ')))
		[12, 3, 4, 5, 6, 7, 8, 9]
		list(filter(isalnum,"12 3 4 5 6 7 8 9".split(' ')))
		def func(s):return s.isalnum()
		list(filter(func,"12 3a 4b 5- 6/ 7 8 9".split(' ')))
		['12', '3a', '4b', '7', '8', '9']
		from functools import reduce #reduce方法需要导入
		reduce(lambda x,y:x+"|"+y,"12 3a 4b 5- 6/ 7 8 9".split(' ')) #lambda表达式引入闭包创建内嵌简单函数
		'12|3a|4b|5-|6/|7|8|9'